<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        body {
            font-family: "Fira Sans", sans-serif;
            margin: 0;
        }

        svg, symbol, use {
            overflow: visible;
        }

        path {
            stroke: none;
            stroke-width: 0;
            fill: #000;
        }

        .svgText {
            height: 1em;
            display: inline-block;
            width: auto;
            overflow: visible;
            font-size: 10em;
            outline: 1px solid #ccc;
        }

        .svgcontainer {
            background: #fff;
            margin: 0.1em;
        }

        a {
            display: block;
            color: inherit;
            text-decoration-color: inherit;
        }

        .btn-default {
            text-decoration: none;
            border-radius: 0.3em;
            padding: 0.5em;
            border: none;
            display: inline-block;
            text-align: center;
            cursor: pointer;
            color: inherit;
            background-color: #222;
            font-family: inherit;
            font-size: inherit;
            margin-bottom: 0.5em;
        }

        .btn-btt {
            position: absolute;
            right: 0;
            z-index: 10;
            bottom: -3em;
        }

        .btn-download {
            font-size: 0.8em;
            color: #fff;
            background-color: #999;
        }

        .fontSvgWrp {
            position: relative;
            display: inline-block;
            margin: 2em;
        }

        .showbaselines .fontSvgWrp:before {
            position: absolute;
            content: "";
            width: 100%;
            left: 0;
            right: 0;
            border-bottom: 1px dotted red;
            font-size: 1em;
            z-index: 1;
            display: block;
        }

        .glyph {
            transition: 0.3s;
        }

        .glyph:hover {
            opacity: 0.5;
        }

        svg {
            height: 5em;
            border: 1px solid #ccc;
            display: inline-block;
        }


        :root {
            --loadingImg: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg%3E%3Ccircle cx='12' cy='2.5' r='1.5' opacity='.14'/%3E%3Ccircle cx='16.75' cy='3.77' r='1.5' opacity='.29'/%3E%3Ccircle cx='20.23' cy='7.25' r='1.5' opacity='.43'/%3E%3Ccircle cx='21.50' cy='12.00' r='1.5' opacity='.57'/%3E%3Ccircle cx='20.23' cy='16.75' r='1.5' opacity='.71'/%3E%3Ccircle cx='16.75' cy='20.23' r='1.5' opacity='.86'/%3E%3Ccircle cx='12' cy='21.5' r='1.5'/%3E%3CanimateTransform attributeName='transform' type='rotate' calcMode='discrete' dur='0.75s' values='0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12' repeatCount='indefinite'/%3E%3C/g%3E%3C/svg%3E");
        }

        .loading {
            background-image: var(--loadingImg);
            background-repeat: no-repeat;
            background-position: 0%;
            color: transparent;
            background-color: rgba(255, 255, 255, 0);
            opacity: 1 !important;
            border-color: transparent;
        }

        ul {
            padding-left:1em;
        }

        ul, li {
            vertical-align:top;
        }
        ul ul ul li,
        ul ul ul ul

        {
            display:inline-block;
            margin-right:0.3em;
        }

        ul ul ul ul
        {
            display:inline-block;
            margin-right:0em;
        }
    </style>
</head>
<body>


<h1>Convert fonts to SVG</h1>


</body>
<div class="layout showbaselines">
    <div class="frm-wrp">
        <p>
            <label>Font file URL: <input class="inputChange" id="inputFont" type="text" value="https://fonts.gstatic.com/s/firasans/v15/va9E4kDNxMZdWfMOD5Vvl4jO.ttf" list="fontList"></label>
            <datalist id="fontList">
                <option value="https://fonts.gstatic.com/s/firasans/v15/va9E4kDNxMZdWfMOD5Vvl4jO.ttf">
                    Fira Sans</option>

                <option value="https://fonts.googleapis.com/css2?family=Rajdhani">
                    Rajdhani</option>

                <option value="https://fonts.gstatic.com/s/opensans/v29/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVQ.woff">
                    Open Sans</option>
                <option value="https://fonts.gstatic.com/s/sourcesanspro/v21/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7l.woff2">
                    Source Sans Pro</option>

                <option value="https://cdn.jsdelivr.net/gh/jossef/material-design-icons-iconfont@master/dist/fonts/MaterialIcons-Regular.ttf">Material icons</option>

                <option value="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2
">Font Awesome 4.7</option>
            </datalist>

            <label>Load font file:
                <input id="inputFile" class="inputChange" type=file accept=".woff2,.woff,.ttf,.otf">
            </label>
        </p>

        <p>

            <label>Test String: <input class="inputChange" id="inputText" type="text" value="Hamburglefonstiv123"></label>

            <label><input class="inputChange" type="checkbox" id="inputCreateSprite" value="1" checked>create
                sprite</label>

            <a id="downloadSprite" class="btn-download btn-default" download="sprite.html" href="">Download Sprite</a>

            <a id="downloadSpriteZip" class="btn-download btn-default" download="sprite.html" href="">Download Zip (including single svgs)</a>

        </p>

        <label>Font size: <input class="inputChange" id="inputFontSize" type="number" value="100"></label>
        <label>Precision: <input class="inputChange" id="inputPrecision" type="number" value="1" min="0" max="5"></label>
        <label><input class="inputChange" type="checkbox" id="inputSingleGlyphs" name="inputSingleGlyphs" value="1">output single glyphs</label>
        <label><input class="inputChange" type="checkbox" id="inputOutputMultiple" name="inputOutputMultiple" value="1">Output multiple svgs (keep previously
            rendered)</label>
        <label><input class="inputChange" type="checkbox" id="showBaseline" name="showBaseline" value="1" checked>show baseline</label>

    </div>

    <fieldset>
        <legend>Font meta</legend>
        <details>
            <summary>Expand Font data</summary>
            <div id="meta"></div>
        </details>
    </fieldset>

    <div class="svgcontainer" id="svgcontainer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.2.2/dist/jszip.js"></script>

<script src="https://unpkg.com/wawoff2@2.0.1/build/decompress_binding.js"></script>
<script src='https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js'></script>

<script>
    function convertObjectToHtml(data) {
        var ul = document.createElement('ul');

        Object.keys(data).forEach(function(key, i) {
            var li = document.createElement('li');
            li.classList.add(`li-${i}`)
            var value = data[key];

            // Skip numeric array keys with a single element
            if (Array.isArray(value) && value.length === 1 && !isNaN(key)) {
                value = value[0];
            }

            var keyLi = document.createElement('li');
            keyLi.classList.add(`keyli-${i}`)

            var keyText = document.createElement('strong');
            keyText.textContent = key+': ';

            if(parseFloat(key)!=key){
                //console.log(key)
                keyLi.appendChild(keyText);
            }

            if (typeof value === 'object') {
                var nestedUl = convertObjectToHtml(value);
                keyLi.appendChild(nestedUl);
            } else {
                var valueText = document.createTextNode(value);
                keyLi.appendChild(valueText);
            }

            li.appendChild(keyLi);
            ul.appendChild(li);
        });

        return ul;
    }


    // Function to convert nested JSON to HTML
    function convertJsonToHtml(jsonData) {
        var ul = document.createElement('ul');

        for (var i = 0; i < jsonData.length; i++) {
            var item = jsonData[i];
            var li = document.createElement('li');

            Object.keys(item).forEach(function(key) {
                var value = item[key];

                // Skip numeric array keys with a single element
                if (Array.isArray(value) && value.length === 1 && !isNaN(key)) {
                    value = value[0];
                }

                var keyLi = document.createElement('li');
                var keyText = document.createTextNode(key + ': ');
                keyLi.appendChild(keyText);

                if (typeof value === 'object') {
                    var nestedUl = convertJsonToHtml([value]);
                    keyLi.appendChild(nestedUl);
                } else {
                    var valueText = document.createTextNode(value);
                    keyLi.appendChild(valueText);
                }

                li.appendChild(keyLi);
            });

            ul.appendChild(li);
        }

        return ul;
    }


</script>
<script>
    let layout = document.querySelector(".layout");
    let svgcontainer = document.querySelector("#svgcontainer");
    let inputText = document.querySelector("#inputText");
    let inputFontSize = document.querySelector("#inputFontSize");
    let inputFont = document.querySelector("#inputFont");
    let inputPrecision = document.querySelector("#inputPrecision");
    let inputSingleGlyphs = document.querySelector("#inputSingleGlyphs");
    let inputShowBaseline = document.querySelector("#showBaseline");
    let inputOutputMultiple = document.querySelector("#inputOutputMultiple");
    let changeFields = document.querySelectorAll(".inputChange");
    let showBaselinesCss = inputShowBaseline.checked ? true : false;
    let createSprite = inputCreateSprite.checked;
    let decimals = +inputPrecision.value;

    // opentype.js accepts woff, ttf and otf
    let fontFile =
        "https://fonts.gstatic.com/s/sourcesanspro/v21/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7l.woff2";

    let sampleText = inputText.value;
    let fontloadOptions = {
        subset: "",
        subsetText: "",
    };

    //default
    let params = {
        string: inputText.value,
        font: fontFile,
        fontSize: +inputFontSize.value,
        decimals: +inputPrecision.value,
        singleGlyphs: false,
    };

    // init
    (async () => {
        let font = await loadFont(fontFile, fontloadOptions);
        processFont(font);

        let baseData = {
            ...font.names,
            ...font.glyphNames,
        };
        //let tree = convertObjectToHtml(baseData);

        let tables = font.tables;
        console.log(baseData);
        console.log(font);
        let tree = convertObjectToHtml(tables);

        //console.log(tree)
        //meta.innerHTML = tree;
        meta.append(tree);
    })();

    async function processFont(font) {
        if (!createSprite) {
            text2Path(font, params);
        } else {
            await showGlyphs(font, params);
            //console.log('update font');
        }
    }

    // load font file
    inputFile.addEventListener("input", function (e) {
        fontFile = e.currentTarget.files[0];
        inputFont.value = "";
    });

    inputFont.addEventListener("input", function (e) {
        fontFile = e.currentTarget.value;
    });

    changeFields.forEach(function (inp, i) {
        inp.addEventListener("input", function (e) {
            createSprite = inputCreateSprite.checked;
            showBaselinesCss = inputShowBaseline.checked ? true : false;
            decimals = +inputPrecision.value;

            if (showBaselinesCss) {
                layout.classList.add("showbaselines");
            } else {
                layout.classList.remove("showbaselines");
            }

            params.string = inputText.value;
            params.font = fontFile;
            params.fontSize = +inputFontSize.value;
            params.decimals = +inputPrecision.value;
            params.singleGlyphs = inputSingleGlyphs.checked ? true : false;

            //delete previous
            if (!inputOutputMultiple.checked) {
                svgcontainer.innerHTML = "";
            }

            (async (e) => {
                let font = await loadFont(fontFile, sampleText);
                processFont(font);
            })();
        });
    });

    /**
     * opentype.js helper
     * Based on @yne's comment
     * https://github.com/opentypejs/opentype.js/issues/183#issuecomment-1147228025
     * will decompress woff2 files
     */
    async function loadFont(src, options = {}) {
        let buffer = {};
        let font = {};
        let ext = "woff2";
        let url;

        // 1. is file
        if (src instanceof Object) {
            // get file extension to skip woff2 decompression
            let filename = src.name.split(".");
            ext = filename[filename.length - 1];
            buffer = await src.arrayBuffer();
        }

        // 2. is base64 data URI
        else if (/^data/.test(src)) {
            // is base64
            let data = src.split(";");
            ext = data[0].split("/")[1];

            // create buffer from blob
            let srcBlob = await (await fetch(src)).blob();
            buffer = await srcBlob.arrayBuffer();
        }

        // 3. is url
        else {
            // if google font css - retrieve font src
            if (/googleapis.com/.test(src)) {
                ext = "woff2";
                src = await getGoogleFontUrl(src, options);
            }

            // might be subset - no extension
            let hasExt =
                src.includes(".woff2") ||
                src.includes(".woff") ||
                src.includes(".ttf") ||
                src.includes(".otf")
                    ? true
                    : false;
            url = src.split(".");
            ext = hasExt ? url[url.length - 1] : "woff2";

            let fetchedSrc = await fetch(src);
            buffer = await fetchedSrc.arrayBuffer();
        }

        // decompress woff2
        if (ext === "woff2") {
            buffer = Uint8Array.from(Module.decompress(buffer)).buffer;
        }

        // parse font
        font = opentype.parse(buffer);
        return font;
    }

    /**
     * load google font subset
     * containing all glyphs used in document
     */
    async function getGoogleFontSubsetFromContent(url, documentText = "") {
        // get all characters used in body
        documentText = documentText
            ? documentText
            : document.body.innerText
                .trim()
                .replace(/[\n\r\t]/g, "")
                .replace(/\s{2,}/g, " ")
                .replaceAll(" ", "");
        url = url + "&text=" + encodeURI(documentText);

        let fetched = await fetch(url);
        let res = await fetched.text();
        let src = res.match(/[^]*?url\((.*?)\)/)[1];

        return src;
    }

    /**
     * load fonts from google helper
     */
    async function getGoogleFontUrl(url, options = {}) {
        let src;
        let subset = options.subset ? options.subset : "latin";
        let subsetText = options.subsetText ? options.subsetText : "";

        // get subset based on used characters
        if (subsetText) {
            src = getGoogleFontSubsetFromContent(url, subsetText);
            return src;
        }
        let fetched = await fetch(url);
        let res = await fetched.text();

        // get language subsets
        let subsetObj = {};
        let subsetRules = res.split("/*").filter(Boolean);

        for (let i = 0; i < subsetRules.length; i++) {
            let subsetRule = subsetRules[i];
            let rule = subsetRule.split("*/");
            let subset = rule[0].trim();
            let src = subsetRule.match(/[^]*?url\((.*?)\)/)[1];
            subsetObj[subset] = src;
        }
        src = subsetObj[subset];

        if (src === undefined) {
            console.log(subsetRules);
            src = subsetRules[0].match(/[^]*?url\((.*?)\)/)[1];
        }

        return src;
    }

    function text2Path(font, params) {
        let options = params.options;
        let unitsPerEm = font.unitsPerEm;
        let ratio = params.fontSize / unitsPerEm;
        let ascender = font.ascender;
        let descender = Math.abs(font.descender);
        let ratAsc = ascender / unitsPerEm;
        let yOffset = params.fontSize * ratAsc;
        let lineHeight = (ascender + descender) * ratio;
        let baseline = +((100 / (ascender + descender)) * descender).toFixed(3) + 2;
        let singleGlyphs = params.singleGlyphs ? params.singleGlyphs : false;

        // get glyph data
        let teststring = params.string.split("");
        let glyphs = font.stringToGlyphs(params.string);
        let firstGlyph = glyphs[0];
        let lastGlyph = glyphs[glyphs.length - 1];
        let leftSB = firstGlyph.leftSideBearing * ratio;
        let rightSB = (lastGlyph.advanceWidth - lastGlyph.xMax) * ratio;
        let textPath = "";
        let path = "";
        let paths = "";
        let stringWidth = 0;

        //individual paths for each glyph
        if (singleGlyphs) {
            paths = font.getPaths(
                params.string,
                -leftSB,
                yOffset,
                params.fontSize,
                options
            );
            paths.forEach(function (path, i) {
                let pathEl = path.toSVG(params.decimals);
                textPath += pathEl.replaceAll(
                    "d=",
                    'class="glyph glyph-' + teststring[i] + '" d='
                );
            });
        }
        //word (all glyphs) merged to one path
        else {
            path = font.getPath(
                params.string,
                -leftSB,
                yOffset,
                params.fontSize,
                options
            );
            textPath += path
                .toSVG(params.decimals)
                .replaceAll("d=", 'class="glyph" d=');
        }

        // render
        let fontSvgWrp = document.createElement("div");
        fontSvgWrp.classList.add("fontSvgWrp");
        let fontSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");

        fontSvg.classList.add("svgText");
        fontSvg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        fontSvg.innerHTML = textPath;
        fontSvgWrp.appendChild(fontSvg);
        svgcontainer.appendChild(fontSvgWrp);

        //strip unnecessary trailing zeroes
        let glyphPaths = fontSvg.querySelectorAll("path");
        glyphPaths.forEach(function (path) {
            let dRounded = parsePathData(path, true);
            if (dRounded) {
                path.setAttribute("d", dRounded);
            }
        });

        // adjust bbox
        if (!singleGlyphs) {
            stringWidth = Math.ceil(path.getBoundingBox().x2);
        } else {
            stringWidth = Math.ceil(
                font.getAdvanceWidth(params.string, params.fontSize, options) -
                leftSB -
                rightSB
            );
        }
        fontSvg.setAttribute("viewBox", "0 0 " + stringWidth + " " + lineHeight);
        fontSvg.setAttribute("width", stringWidth);
        fontSvg.setAttribute("height", lineHeight);
        fontSvg.setAttribute("data-desc", baseline);

        //add downloadbtn
        let filename = params.string + ".svg";
        let content = fontSvg.outerHTML;
        addDownloadBtn(fontSvgWrp, filename, content);
        showBaselines();
    }

    function showBaselines() {
        let fontSvgWrp = document.querySelectorAll(".fontSvgWrp");
        fontSvgWrp.forEach(function (el, i) {
            let textPath = el.querySelector(".svgText");
            let baselineY = +textPath.getAttribute("data-desc");
            el.setAttribute("style", "--baseline:" + baselineY + "%");
        });
    }

    function parsePathData(data, returnString = false) {
        // use d attribute or data if already string of commands
        let dataType = data.nodeType;
        let d = dataType ? data.getAttribute("d") : data;
        let output = "";
        if (d) {
            let pathData = [];
            let commandStringOpt = "";
            let commands = d.match(/([mcsqtalvhz]+[-.,\d ]*)/gi);
            /* now parse each piece into its own array */
            if (commands.length) {
                for (let i = 0; i < commands.length; i++) {
                    let command = commands[i].match(/([mcsqtalvhz]+|-?[.\d]*\d)/gi);
                    let type = command[0];
                    command.shift();
                    let values = command.map((val) => {
                        return +parseFloat(val).toFixed(decimals);
                    });
                    pathData.push({
                        type: type,
                        values: values,
                    });
                    commandStringOpt += `${type}${values.join(" ")} `;
                }
                output = returnString ? commandStringOpt : pathData;
            }
        }
        return output;
    }

    async function showGlyphs(font, params) {
        let unitsPerEm = font.unitsPerEm;
        let ratio = params.fontSize / unitsPerEm;
        let ascender = font.ascender;
        let descender = Math.abs(font.descender);
        //let ratAsc = ascender / unitsPerEm;
        //let ratDesc = descender / unitsPerEm;
        //let yOffset = params.fontSize * ratAsc;
        //let lineHeight = (ascender + descender) * ratio;
        //let baseline = +((100 / (ascender + descender)) * descender).toFixed(3) + 2;

        let glyphs = font.glyphs.glyphs;
        let keys = Object.keys(glyphs).length;

        let htmlOutput = "";
        let useMarkup = "";

        //console.log(glyphs);

        /**
         * zip single icons
         */
            // let zipSVGs = [];
        let zip = new JSZip();
        //console.log('showGlyphs');

        for (let i = 0; i < keys; i++) {
            let glyph = glyphs[i];
            let lineHeight = (ascender + descender) * ratio;
            let leftSB = glyph.leftSideBearing * ratio;
            let rightSB = (glyph.advanceWidth - glyph.xMax) * ratio;
            let glyphW = glyph.advanceWidth * ratio;
            let poxX = 0;

            // adjust negative widths
            if (glyph.advanceWidth + leftSB < 0) {
                glyphW =
                    Math.abs(leftSB) + Math.abs(glyph.advanceWidth) + Math.abs(rightSB);
                poxX = Math.abs(leftSB);
            }

            // get svg path
            let pathData = glyph
                .getPath(poxX, ascender * ratio, params.fontSize)
                .toPathData(decimals);

            let glyphId = glyph.name
                ? glyph.name.replaceAll(".", "_")
                : glyph.unicode
                    ? glyph.unicode
                    : glyph.index;

            if (pathData) {
                let glyphSvg = `<svg xmlns="http://www.w3.org/2000/svg" id="icon_${glyphId}" viewBox="0 0 ${+glyphW.toFixed(
                    2
                )} ${+lineHeight.toFixed(2)}">
            <path d="${pathData}" id="path_${glyphId}" />
      </svg>`;
                //zipSVGs.push(glyphSvg);
                zip.file(`svgs/icon_${glyphId}.svg`, glyphSvg);

                //console.log(glyphSvg);

                if (inputCreateSprite.checked) {
                    // add symbol
                    htmlOutput += `<symbol id="symbol_${glyphId}" data-id="${
                        glyph.index
                    }" viewBox="0 0 ${+glyphW.toFixed(2)} ${+lineHeight.toFixed(2)}">
                <path d="${pathData}" id="path_${glyphId}" />
              </symbol>`;

                    useMarkup += `<svg id="use_wrap_${glyphId}"  viewBox="0 0 ${+glyphW.toFixed(
                        2
                    )} ${+lineHeight.toFixed(2)}">
              <use href="#symbol_${glyphId}" />
            </svg>
              `;
                } else {
                    htmlOutput += glyphSvg;
                }
            }
        }

        let fontFamily = font.tables.name.fontFamily.en
            .replaceAll(" ", "_")
            .replaceAll(".", "_");
        if (inputCreateSprite.checked) {
            htmlOutput =
                `<svg xmlns="http://www.w3.org/2000/svg" id="sprite_${fontFamily}" style="width:0; height:0; position:absolute; overflow:hidden;">` +
                htmlOutput +
                `</svg>`;
        }
        // write html
        htmlOutput += useMarkup;
        svgcontainer.innerHTML = htmlOutput;

        // write download for spritesheet
        let htmlDoc = `
<html>
<head>
    <style>
    body{font-family:sans-serif}
    svg {
            height: 5em;
            border: 1px solid #ccc;
            display: inline-block;
    }
</style>
</head>
<body>
<h1>${fontFamily}: sprite</h1>
${htmlOutput}
</body>
</html>`;

        // simple html download
        let blobHtml = new Blob([htmlDoc], { type: "text/plain" });
        let urlHtml = window.URL.createObjectURL(blobHtml);
        downloadSprite.href = urlHtml;

        // zip download
        zip.file(`index.html`, htmlDoc);

        // toggle loading spinner
        downloadSpriteZip.classList.add("loading");
        let blob = await zip.generateAsync({
            type: "blob",
        });

        let url = URL.createObjectURL(blob);
        downloadSpriteZip.href = url;
        downloadSpriteZip.download = `sprite_${fontFamily}.zip`;
        downloadSpriteZip.classList.remove("loading");
    }

    function addDownloadBtn(el, filename, content) {
        let btnDownload = document.createElement("a");
        btnDownload.setAttribute("download", filename);
        btnDownload.classList.add("btn-download", "btn-default", "btn-btt");
        btnDownload.textContent = "Download";
        let dataURl = getDataUrl(content, "image/svg+xml");
        btnDownload.href = dataURl;
        el.appendChild(btnDownload);
    }

    function getDataUrl(str, mime) {
        let dataUrl =
            "data:" + mime + ";base64," + btoa(unescape(encodeURIComponent(str)));
        return dataUrl;
    }

    keepDatalistOptions();

    function keepDatalistOptions(selector = "") {
        // select all input fields by datalist attribute or by class/id
        selector = !selector ? "input[list]" : selector;
        let datalistInputs = document.querySelectorAll(selector);
        if (datalistInputs.length) {
            for (let i = 0; i < datalistInputs.length; i++) {
                let input = datalistInputs[i];
                input.addEventListener("input", function (e) {
                    e.target.setAttribute("placeholder", e.target.value);
                    e.target.blur();
                });
                input.addEventListener("focus", function (e) {
                    e.target.setAttribute("placeholder", e.target.value);
                    e.target.value = "";
                });
                input.addEventListener("blur", function (e) {
                    e.target.value = e.target.getAttribute("placeholder");
                });
            }
        }
    }


</script>
</html>